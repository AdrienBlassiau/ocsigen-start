(* Eliom-base-app
 * http://www.ocsigen.org/eliom-base-app
 *
 * Copyright (C) 2014
 *      Charly Chevalier
 *      Vincent Balat
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)

(*VVV WHAT IS IT?? *)
val doc_start : unit

(** This module defines all functor application module signatures. *)

(** Groups module needed by EBA to implement permissions on connected pages
  * and connected fun (module [Session] and [Page]). *)
module type Groups = sig
  (** The type of a group. *)
  type t

  (** Determin if a userid belongs or not, to a group. *)
  val in_group : group:t -> userid:int64 -> bool Lwt.t
end

(** Session module helps you *)
module type Session = sig
  (** A type which represents a group. A user can belongs to a group or not.
    * You have to provide an interface of your group representation. *)
  type group

  (** Explicitly connect the user. (on both side) *)
  val connect : int64 -> unit Lwt.t

  (** Explicitly disconnect the connected user (it takes no parameter because
    * EBA cache connection information for the current user). *)
  val disconnect : unit -> unit Lwt.t

  (** Wrap a function which takes get and post paramters and the uid
    * of the user as first parameter and call it only if the user is
    * connected, otherwise it raise Not_connected. *)
  val connected_fun :
     ?allow:group list
  -> ?deny:group list
  -> ?deny_fun:(int64 option -> 'c Lwt.t)
  -> (int64 -> 'a -> 'b -> 'c Lwt.t)
  -> 'a -> 'b
  -> 'c Lwt.t

  (** Same as [connect_wrapper_function] but only takes two parameters,
    * the uid and post parameters. You should use this wrapper for your
    * rpc ([Eliom_pervasives.server_function]). *)
  val connected_rpc :
     ?allow:group list
  -> ?deny:group list
  -> ?deny_fun:(int64 option -> 'b Lwt.t)
  -> (int64 -> 'a -> 'b Lwt.t)
  -> 'a
  -> 'b Lwt.t

  module Opt : sig
    (** Same as above but instead of raising an Not_connected, the first
      * parameter is wrapped into an option, None tells you that the user
      * is currently not connected. *)
    val connected_fun :
       ?allow:group list
    -> ?deny:group list
    -> ?deny_fun:(int64 option -> 'c Lwt.t)
    -> (int64 option -> 'a -> 'b -> 'c Lwt.t)
    -> 'a -> 'b
    -> 'c Lwt.t

    (** Same as [connected_wrapper] but the first parameter is wrapped into
      * an option and None represents a non-connected user. *)
    val connected_rpc :
       ?allow:group list
    -> ?deny:group list
    -> ?deny_fun:(int64 option -> 'b Lwt.t)
    -> (int64 option -> 'a -> 'b Lwt.t)
    -> 'a
    -> 'b Lwt.t

  end

end


(** EBA defines two kinds of pages, connected pages and non-connected pages.
  * These page can have a [fallback] functions which is called if something
  * went wrong during the generation of the page and they can also add some
  * conditions to their generations process. *)
module type Page = sig

  (** Same as the [Session] module generated by the main functor of EBA. *)
  module Session : Session

  module Opt : sig
  (** The main function to generate pages for connected or non-connected user.
      The optional user id is given to the function as first argument.
      The arguments [allow] and [deny] represents groups to which
      the user has to belongs or not. If the user does not
      respect these requirements, the [fallback] function will be
      used.
  *)
    val connected_page :
      ?allow:Session.group list
      -> ?deny:Session.group list
      -> ?predicate:(int64 option -> 'a -> 'b -> bool Lwt.t)
      -> ?fallback:(int64 option -> 'a -> 'b -> exn ->
                    [ Html5_types.body_content ] Eliom_content.Html5.elt
                      list Lwt.t)
      -> (int64 option -> 'a -> 'b ->
          [ Html5_types.body_content ] Eliom_content.Html5.elt list Lwt.t)
      -> 'a -> 'b
      -> [ Html5_types.html ] Eliom_content.Html5.elt Lwt.t
  end

  (** Generate a page visible for non-connected and connected user.
      Use the [predicate] function if you have something to check
      before the generation of the page. If [predicate] returns
      [false], the page will be generated using the [fallback]
      function. *)
  val page :
       ?predicate:('a -> 'b -> bool Lwt.t)
    -> ?fallback:('a -> 'b -> exn ->
                  [ Html5_types.body_content ] Eliom_content.Html5.elt
                    list Lwt.t)
    -> ('a -> 'b -> [ Html5_types.body_content ] Eliom_content.Html5.elt list
          Lwt.t)
    -> 'a -> 'b
    -> [ Html5_types.html ] Eliom_content.Html5.elt Lwt.t

  (** Generate a page only visible for connected user.
      It behaves like [Opt.connected_page] but will display
      the fallback if not connected.
      The predicate is checked only for connected users.
  *)
  val connected_page :
       ?allow:Session.group list
    -> ?deny:Session.group list
    -> ?predicate:(int64 option -> 'a -> 'b -> bool Lwt.t)
    -> ?fallback:(int64 option -> 'a -> 'b -> exn ->
                  [ Html5_types.body_content ] Eliom_content.Html5.elt list
                    Lwt.t)
    -> (int64 -> 'a -> 'b ->
        [ Html5_types.body_content ] Eliom_content.Html5.elt list Lwt.t)
    -> 'a -> 'b
    -> [ Html5_types.html ] Eliom_content.Html5.elt Lwt.t
end

(** Email module : TODO *)
module type Email = sig
  exception Invalid_mailer of string

  (** The pattern used to match an email *)
  val email_pattern : string

  (** Check if the given email is valid or not *)
  val is_valid : string -> bool

  (** Send an email to [to_addrs]. You have to define the [subject] of your
    * email. The body of the email is a list of string
    * and each element of the list is automatically separated by a new line. *)
  val send :    ?from_addr:(string * string)
             -> to_addrs:((string * string) list)
             -> subject:string
             -> string list
             -> unit
end

(** This module attemps to follow the same design of the flash messages in
  * RoR.
  *
  * A request message lives only once during a request. Each new request
  * will clear the value of a request message.
  *
  * You could use request messages in case of submitted forms. To report
  * potentially errors, or just to notice the user that is accound has
  * been created.
  *
  * You can also use request message to pass value between the different
  * parts of your request.
  * *)
module type Reqm = sig
  (** The type of the html representation of request messages. *)
  type html = Html5_types.div Eliom_content.Html5.elt

  (** The type of a basic request message. *)
  class type virtual reqm_base = object
    method virtual to_html : html
  end

  (** The type of a request message. *)
  class type ['a] reqm = object
    inherit reqm_base

    method set : 'a -> unit
    method clear : unit
    method has : bool
    method get : 'a
    method get_opt : 'a option
    method to_html : html
  end

  (** The type of a [set] of {b request messages}. [set] can be used to store
    * any kind of {b request messages}. Once they are stored, you can get them
    * in readonly mode ([reqm_base] instance). *)
  type set

  (** Use these helpers to enforce the type of your request message on creation. *)
  type 'a cons
  val cons : 'a cons

  (** Create a new set. *)
  val create_set : string -> set

  (** Create a new request message. You can use [cons] label to enforce the type
    * of the request message.
    *
    * The functions [to_html] will be used in the readonly
    * represetation of your request message. The value of type ['a] will be
    * passed as parameter to these functions.
    * *)
  val create :
       ?cons:'a cons
    -> ?set:set
    -> ?default:(unit -> 'a)
    -> to_html:('a -> html)
    -> unit
    -> 'a reqm

  (** Returns the html representation of the request message. *)
  val to_html : #reqm_base -> html

  (** Set a value for the given request message. *)
  val set : 'a reqm -> 'a -> unit
  (** Helper to push an element into a list. *)
  val push : 'a list reqm -> 'a -> unit
  (** Get the value of a request message. May raise [No_value] if no value has
    * been sefwakor the request message. You can use the function [has] to know
    * if there is a value associated to the request message. *)
  val get : 'a reqm -> 'a
  (** Get the value of a request message using ['a option] type. *)
  val get_opt : 'a reqm -> 'a option
  (** Returns [true] if a value has been set for the request message. *)
  val has : 'a reqm -> bool
  (** Clear the value of a request message. Ignored in case of unset value. *)
  val clear : 'a reqm -> unit

  (** Get the name of a set. *)
  val name_of_set : set -> string
  (** Get all the request messages {b with a value} which belongs to
    * the given [set]. *)
  val to_list : set -> reqm_base list
end

module type State = sig
  type state
  type t = (state * string * string option)

  val name_of_state : state -> string
  val desc_of_state : state -> string
  val fun_of_state : state -> (unit, unit) Eliom_pervasives.server_function
  val descopt_of_state : state -> string option

  val set_website_state : state -> unit Lwt.t
  val get_website_state : unit -> state Lwt.t

  val all : unit -> (state list)
end

(** This module provides some useful tools (cache system, ..). *)
module Tools : sig
  (** A module which provides cache system functionalities. All the stored values
    * are reset each requests. *)
  module type Cache_sig = sig
    (** The type of the key *)
    type key_t
    (** The type of the value *)
    type value_t

    (** Returns [true] if the key has been stored into the cache. *)
    val has : key_t -> bool
    (** Set the corresponding [value] for a key. *)
    val set : key_t -> value_t -> unit

    (** Explicitly reset a [value] for the given key. *)
    val reset : key_t -> unit
    (** Get the value corresponding to the given key. *)
    val get : key_t -> value_t Lwt.t
    (** Not so useful.. Should be removed I think. *)
    val wrap_function : key_t -> (unit -> 'a Lwt.t) -> 'a Lwt.t
  end
  module type Cache_f = sig
    module Make : functor
      (M : sig
         (** The type of your key. *)
         type key_t
         (** The type of the stored value. *)
         type value_t

         (** The function used to compare keys. *)
         val compare : key_t -> key_t -> int
         (** This function is called when the value corresponding to a key
           * is not yet stored into the cache. *)
         val get : key_t -> value_t Lwt.t
       end) -> Cache_sig with type key_t = M.key_t and type value_t = M.value_t
  end
end

module type Tools = sig
  module Cache_f : Tools.Cache_f
end
